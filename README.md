# North soul - 1 chapter / Документация

---

# Содержание

- [Введение](#введение)
- [Основные понятия](#основные-понятия)
- [Основные типы](#основные-типы)
  - [Объекты](#объекты)
  - [Триггер](#триггер)
  - [События](#события)
- [Специальные типы](#специальные-типы)
  - [Главные элементы](#главные-элементы)
  - [UI элементы](#ui-элементы)
- [Задачи](#задачи)
  - [Реализованные](#реализованные)
  - [Не реализованный](#не-реализованный)
- [Ресурсы](#ресурсы)
- [FAQ](#faq)

---

# Введение

В данном файле будет рассказано, как пользоваться кодом, какие моменты и особенности есть, и так далее. Файл с каждым написанным классом в Unity будет будет обновляться и дополняться информацией, чтобы без проблем было понятно как и что работает.

Если подытожить - данный файл будет служить справочником и позволит быстро и легко разобраться в особенностях работы каждого из классов.

Данный файл будет много раз переделываться!
Я уверен (Чикса), что данный файл скорее всего будет не понятен. Поэтому ждём и терпим.

---

# Основные понятия

Основные типы - самый многочисленные компоненты в нашем проекте, от триггеров до предметов.
Специальные типы - классы, которые существуют в единственном экземпляре.
Инспектор - то, что появляется в панеле _Inspector_.

---

# Основные типы

## Объекты

#### Предмет

Класс `ItemData` отвечает за предметы в игре. Наследуется от `ScriptableObject`.

> Инспектор: `int:Id`; `string:Name`; `string:Description`; `Sprite:Icon`;
> Свойства: `int:Index`; `string:Name`; `string:Description`; `Sprite:Icon`;

Статичный класс `RegistryItem`. В нём реализовано хранение всех предметов из папки _Resources/Items_. И из него можно получать предметы с помощью метода `TryGet`.

> Статичные методы: `void:Registry()`; `ItemData:TryGet(int)`;

---

#### Комнаты

Структура `Room` отвечает за комнату в проекте. С помощью статичной переменной `_lastIndex` назначается идентификатор комнаты. Содержит 4 переменных, из которых стоит выделить:

- `PointLeftUp` - хранит позицию верхне левого угла.
- `PointRightDown` - хранит позицию нижний правого угла.
- `Light` - хранит данные света.

> Переменные: `int:Index`; `Vector2:PointLeftUp`; `Vector2:PointRightDown`; `Light2D:Light`;
> Свойства: `float:LeftX`; `float:RightX`; `float:UpY`; `float:DownY`;

Класс `UnityRoom` наследуется от `MonoBehaviour`, который регистрирует комнаты. После метода `Start()` данный компонент уничтожается.

> Инспектор: `Vector2:PointLeftUp`; `Vector2:PointRightDown`; `Light2D:Light`;

Статичный класс `RegistryRoom` хранит данные о комнатах. Метод `Find()` определяет, находится ли какой-либо объект в комнате.

> Статичные методы: `void:Clear()`; `void:Add(Room)`; `Room?:Find(Vector3)`;

---

#### Враги

Класс `EnemyAI` наследуется от `MonoBehaviour`. Простенький бот, который при свете (или если комнаты нет) исчезает. Перемещается только по `x`.

---

#### Игрок

Класс `Player` является ядром для сущности _игрока_. Наследуется от `MonoBehaviour`. В нём реализована _Анимация_, _Движение_ и _Инвентарь_ в соотвествующих классах.

> Инспектор: `float:Speed`; `Animator:Animator`;`int:Count Item`;

Класс `Move` реализует движение и поворот игрока. Статичный метод `GetSpeed` получает скорость из того, что нажал игрок.

> Методы: `void:Run()`;
> Статичные методы: `float:GetSpeed()`;

Класс `Animation` реализует анимацию игрока. Просто отслеживает параметры и меняет состояние.

> Методы: `void:Run()`;

Класс `Inventory` реализует инвентарь любой сущности (возможно только для игрока). Имеет интерфейс `IEnumerable`. Инвентарь имеет максимальное количество слотов. С помощью методов можно добавлять `Add()`, удалять `Remove()`, узнать, есть ли свободные места `IsTherePlace()` и есть ли предмет `Contain()`.

> Свойства: `IReadOnlyList<ItemData>:Items`; `int:Count`; `int:MaxCount`;
> Методы: `void:Add(ItemData)`; `void:Remove(ItemData)`; `bool:IsTherePlace()`; `bool:Contain(ItemData)`;

---

#### Остальное

Класс `TextData` является объектом, который хранит диалоги и тексты. Наследуется от `ScriptableObject`. В нём хранится 3 закрытых переменных:

- `_name` - идентификатор объекта.
- `_nextText` - следующий объект.
- `_text` - текущий текст.
  Есть такие же свойства. К ним добавляется свойство `IsEnd`, возращающий `true`, если нет следующего объекта текста.

> Инспектор гаджет: `string:Name`; `TextData:Next Text`; `string:Text`;
> Свойства: `string:Name`; `TextData:NextText`; `string:Text`; `bool:IsEnd`;

Класс `CompletedActions` является хранилищем для выполненых действий. К примеру - игрок выполнил действие _Испугаться призрака_. Оно записывается в данное хранилище.

> Методы: `void:Add(string)`; `bool:Contain(string)`;

---

## Триггер

#### Класс триггера

Класс `Trigger` представляет собой объект, которое приводит к развитию определённого действия или ситуации.. Наследуется от `MonoBehaviour`. Имеет несколько разделов для настройки, а именно:

- `Tag` - на какой тег реагировать.
- `Is Button` - требуется ли нажать или только коснуться триггера.
- `Is Loop` - повториться ли триггер. (Если нет, то триггер удалиться).
- `Type Criterion` - какой тип условия требуется.
- `On Work Trigger` - события, которые сработают, когда триггер активируется. Если есть условие, то оно должно выполниться.
- Если условие требует предмет (`PresentItem`):

  - `Item` - предмет, который требуется.
  - `On Not Work Trigger` - события, которые сработают, если триггер не сработает. Требуется условие.

- Если условие требует событие (`DoneAction`):
  - `Name Action` - событие, которое требуется.
  - `On Not Work Trigger` - события, которые сработают, если триггер не сработает. Требуется условие.

> Инспектор: `bool:Is Button`; `bool:Is Loop`; `string:Tag`; `TypeCriterion:Type Criterion`; `UnityEvent<GameEventArgs>:On Work Trigger`; `UnityEvent<GameEventArgs>:On Not Work Trigger`; `string:Name Action`; `ItemData:Item`;  
> Свойства: `bool:IsEmptyObject`; `GameObject:Gameobject`;

---

#### Типы условий

Перечисление `TypeCriterion` представляет тип условия для срабатывания триггера.

- `None` - без условий.
- `PresentItem` - при условий, что у игрока есть определённый предмет.
- `DoneAction` - при условий, что определённое событие произошло.

---

## События

> **Важно!** Скорее всего будет переделываться.

#### Родитель событий

Абстрактный класс `AbstractAction` наследуется от `MonoBehaviour`. Служит для реализаций событий.

> Методы: `void:Run(GameEventArgs)`;

Его перегрузка `AbstractAction<In>` даёт возможность передать какую-то переменную типа `In` 2 аргументом. ~~Честно, он бесполезный.~~

> Методы: `void:Run(GameEventArgs, In)`;

---

#### Конкретные события

Класса `GiveItem` реализует события получения предмета. Если в карманах нет места, то ничего мы не получаем. На вход назначаем предмет и указываем, нужен ли вывод текста об этом.

> Инспектор: `ItemData:Item`; `bool:Is Show Text`;
> Методы: `void:Run(GameEventArgs)`;

Класса `Ladder` реализует перемещение между этажами. На вход получает или объект _(Target Object)_, или позицию _(Target Position)_, куда нужно переместиться.

> Инспектор: `ItemData:Item`; `bool:Is Show Text`;
> Методы: `void:Run(GameEventArgs)`;

Класса `OpenDoor` реализует открытие двери. На вход назначаем открытую и закрытую дверь.

> Инспектор: `GameObject:Door Open`; `GameObject:Door Close`; `bool:Is Open Door`;
> Методы: `void:Run(GameEventArgs)`;

Класса `WorkCompletedAction` реализует то, что какое-то событие произошло. На вход назначаем название событию.

> Инспектор: `string:Action`;`;
Методы: `void:Run(GameEventArgs)`;

Класса `WorkLight` реализует работу со светом. На вход назначаем свет и тип работы света. Есть стандартный режим _(Standart)_ и режим по таймеру _(DuringTime)_. По таймеру дополнительно нужно указать период.

> Инспектор: `WorkTypeLight:Work Type Light`; `Light2D:Light`; `float:Period`;
> Методы: `void:Run(GameEventArgs)`;

Класса `WorkText` показывает текст. На вход получает `TextData` в первой ячейки. ~~Пока что тут такой костыль, что п\*здец.~~ С помощью метода `RunText()` можно вызвать конкретный _диалог_ через названия. Обязательно он должен быть в `Datas`.

> Инспектор: `List<TextData>:Datas`;
> Методы: `void:Run(GameEventArgs)`; `void:RunText(nameDatasData)`;

---

#### Аргументы события

Структура `GameEventArgs` требуется для передачи аргументов. В нем храниться пока что только `GameObject`.

> Свойства:`GameObject:Object`;

---

# Специальные типы

## Главные элементы

#### Класс GameCore

Данный класс является главным ядром игры. Он контролирует запуск важных объектов. Через него можно получить `Player`, `PanelComponent` и `CompletedActions`.

> Инспектор: `GameObject:Player`
> Статичные свойства:`PanelComponent:PanelSingleton`; `GameObject:PlayerObjectSingleton`; `Player:PlayerSingleton`;
> Статичные методы:`void:AddAction(string)`; `bool:ContainAction(string)`;

---

#### Класс Settings

Данный объект просто хранит настройки игры. Пока что только клавиши.

> Статичные свойства:`KeyCode:KeySprint`; `KeyCode:KeyUse`; `KeyCode:KeyEcs`;

---

#### Класс EventGame

Данный класс просто хранит все Event, по типу _Смерти игрока_ или _Открытие меню_. ~~Я ещё не использовал~~

> Статичные переменные:`Action:OnDeadPlayer`; `Action:OnEnableMenu`;
> Статичные методы:`void:InvokeEnableMenu()`; `void:InvokeDeadPlayer()`;

---

## UI элементы

#### Класс PanelComponent

Данный объект отвечает за интерфейс игры. Он контролирует запуск важных UI объектов, а конкретно `InventoryView`, `TextView` `MenuView`. Отвечает за меню игры.

> Инспектор: `Image:Fon Text`; `Text:Text`; `GameObject:Inventory View Object`; `Image[]:Images`; `GameObject:Menu`; `Image:Black Fon`;
> Свойства: `TextView:TextView`;
> Методы: `void:MenuOn()`; `void:MenuOff()`; `IEnumerator:TransitionOn(float, float)`; `IEnumerator:TransitionOff(float, float)`;

---

#### Класс InventoryView

> **Важно!** Будет переделываться.

Данный класс выводит инвентарь при вызове меню. Метод `ViewOn` показывает инвентарь, а `ViewOff` скрывает его.

> Методы: `void:ViewOn()`; `void:ViewOff()`;

---

#### Класс TextView

Данный класс выводит текст когда он вызывается через событие. Метод `PrintText` выводит текст, пока не закончится диалог.

> Методы: `IEnumerator:PrintText(string)`; `IEnumerator:PrintText(ItemData)`;

---

#### Класс MenuView

Данный класс отвечает за кнопки меню (справа). Метод `ViewOn` показывает кнопки, а `ViewOff` скрывает их.

> Методы: `void:ViewOn()`; `void:ViewOff()`;

---

# Задачи

## Реализованные

- [x] Проект в Unity
- [x] Триггеры
- [x] Разные События

## Не реализованный

- [ ] Сюжета
- [ ] Спрайт

# Ресурсы

Тут собраны все ресурсы и документы, которые связанны с игрой:

- Наш Word документ в Google: [Ссылка](https://docs.google.com/document/d/1n0JIn9Ls94T0J5MFFFV46SRSVGQsCsS5wINYcpnWwGQ/edit?usp=sharing)

# FAQ

Будет дополнен.
